/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 5.27.2
 * source: observe.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export namespace observe {
    export class ObserveOptions extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            origin?: ObserveOrigin;
            parser?: ParserType;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("origin" in data && data.origin != undefined) {
                    this.origin = data.origin;
                }
                if ("parser" in data && data.parser != undefined) {
                    this.parser = data.parser;
                }
            }
        }
        get origin() {
            return pb_1.Message.getWrapperField(this, ObserveOrigin, 1) as ObserveOrigin;
        }
        set origin(value: ObserveOrigin) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_origin() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get parser() {
            return pb_1.Message.getWrapperField(this, ParserType, 2) as ParserType;
        }
        set parser(value: ParserType) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_parser() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            origin?: ReturnType<typeof ObserveOrigin.prototype.toObject>;
            parser?: ReturnType<typeof ParserType.prototype.toObject>;
        }): ObserveOptions {
            const message = new ObserveOptions({});
            if (data.origin != null) {
                message.origin = ObserveOrigin.fromObject(data.origin);
            }
            if (data.parser != null) {
                message.parser = ParserType.fromObject(data.parser);
            }
            return message;
        }
        toObject() {
            const data: {
                origin?: ReturnType<typeof ObserveOrigin.prototype.toObject>;
                parser?: ReturnType<typeof ParserType.prototype.toObject>;
            } = {};
            if (this.origin != null) {
                data.origin = this.origin.toObject();
            }
            if (this.parser != null) {
                data.parser = this.parser.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_origin)
                writer.writeMessage(1, this.origin, () => this.origin.serialize(writer));
            if (this.has_parser)
                writer.writeMessage(2, this.parser, () => this.parser.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ObserveOptions {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ObserveOptions();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.origin, () => message.origin = ObserveOrigin.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.parser, () => message.parser = ParserType.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): ObserveOptions {
            return ObserveOptions.deserialize(bytes);
        }
    }
    export class DltParserSettings extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            filter_config?: DltFilterConfig;
            fibex_file_paths?: string[];
            with_storage_header?: boolean;
            tz?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("filter_config" in data && data.filter_config != undefined) {
                    this.filter_config = data.filter_config;
                }
                if ("fibex_file_paths" in data && data.fibex_file_paths != undefined) {
                    this.fibex_file_paths = data.fibex_file_paths;
                }
                if ("with_storage_header" in data && data.with_storage_header != undefined) {
                    this.with_storage_header = data.with_storage_header;
                }
                if ("tz" in data && data.tz != undefined) {
                    this.tz = data.tz;
                }
            }
        }
        get filter_config() {
            return pb_1.Message.getWrapperField(this, DltFilterConfig, 1) as DltFilterConfig;
        }
        set filter_config(value: DltFilterConfig) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_filter_config() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get fibex_file_paths() {
            return pb_1.Message.getFieldWithDefault(this, 2, []) as string[];
        }
        set fibex_file_paths(value: string[]) {
            pb_1.Message.setField(this, 2, value);
        }
        get with_storage_header() {
            return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
        }
        set with_storage_header(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        get tz() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set tz(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            filter_config?: ReturnType<typeof DltFilterConfig.prototype.toObject>;
            fibex_file_paths?: string[];
            with_storage_header?: boolean;
            tz?: string;
        }): DltParserSettings {
            const message = new DltParserSettings({});
            if (data.filter_config != null) {
                message.filter_config = DltFilterConfig.fromObject(data.filter_config);
            }
            if (data.fibex_file_paths != null) {
                message.fibex_file_paths = data.fibex_file_paths;
            }
            if (data.with_storage_header != null) {
                message.with_storage_header = data.with_storage_header;
            }
            if (data.tz != null) {
                message.tz = data.tz;
            }
            return message;
        }
        toObject() {
            const data: {
                filter_config?: ReturnType<typeof DltFilterConfig.prototype.toObject>;
                fibex_file_paths?: string[];
                with_storage_header?: boolean;
                tz?: string;
            } = {};
            if (this.filter_config != null) {
                data.filter_config = this.filter_config.toObject();
            }
            if (this.fibex_file_paths != null) {
                data.fibex_file_paths = this.fibex_file_paths;
            }
            if (this.with_storage_header != null) {
                data.with_storage_header = this.with_storage_header;
            }
            if (this.tz != null) {
                data.tz = this.tz;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_filter_config)
                writer.writeMessage(1, this.filter_config, () => this.filter_config.serialize(writer));
            if (this.fibex_file_paths.length)
                writer.writeRepeatedString(2, this.fibex_file_paths);
            if (this.with_storage_header != false)
                writer.writeBool(3, this.with_storage_header);
            if (this.tz.length)
                writer.writeString(4, this.tz);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DltParserSettings {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DltParserSettings();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.filter_config, () => message.filter_config = DltFilterConfig.deserialize(reader));
                        break;
                    case 2:
                        pb_1.Message.addToRepeatedField(message, 2, reader.readString());
                        break;
                    case 3:
                        message.with_storage_header = reader.readBool();
                        break;
                    case 4:
                        message.tz = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): DltParserSettings {
            return DltParserSettings.deserialize(bytes);
        }
    }
    export class DltFilterConfig extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            min_log_level?: number;
            app_ids?: string[];
            ecu_ids?: string[];
            context_ids?: string[];
            app_id_count?: number;
            context_id_count?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2, 3, 4], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("min_log_level" in data && data.min_log_level != undefined) {
                    this.min_log_level = data.min_log_level;
                }
                if ("app_ids" in data && data.app_ids != undefined) {
                    this.app_ids = data.app_ids;
                }
                if ("ecu_ids" in data && data.ecu_ids != undefined) {
                    this.ecu_ids = data.ecu_ids;
                }
                if ("context_ids" in data && data.context_ids != undefined) {
                    this.context_ids = data.context_ids;
                }
                if ("app_id_count" in data && data.app_id_count != undefined) {
                    this.app_id_count = data.app_id_count;
                }
                if ("context_id_count" in data && data.context_id_count != undefined) {
                    this.context_id_count = data.context_id_count;
                }
            }
        }
        get min_log_level() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set min_log_level(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get app_ids() {
            return pb_1.Message.getFieldWithDefault(this, 2, []) as string[];
        }
        set app_ids(value: string[]) {
            pb_1.Message.setField(this, 2, value);
        }
        get ecu_ids() {
            return pb_1.Message.getFieldWithDefault(this, 3, []) as string[];
        }
        set ecu_ids(value: string[]) {
            pb_1.Message.setField(this, 3, value);
        }
        get context_ids() {
            return pb_1.Message.getFieldWithDefault(this, 4, []) as string[];
        }
        set context_ids(value: string[]) {
            pb_1.Message.setField(this, 4, value);
        }
        get app_id_count() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set app_id_count(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get context_id_count() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set context_id_count(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        static fromObject(data: {
            min_log_level?: number;
            app_ids?: string[];
            ecu_ids?: string[];
            context_ids?: string[];
            app_id_count?: number;
            context_id_count?: number;
        }): DltFilterConfig {
            const message = new DltFilterConfig({});
            if (data.min_log_level != null) {
                message.min_log_level = data.min_log_level;
            }
            if (data.app_ids != null) {
                message.app_ids = data.app_ids;
            }
            if (data.ecu_ids != null) {
                message.ecu_ids = data.ecu_ids;
            }
            if (data.context_ids != null) {
                message.context_ids = data.context_ids;
            }
            if (data.app_id_count != null) {
                message.app_id_count = data.app_id_count;
            }
            if (data.context_id_count != null) {
                message.context_id_count = data.context_id_count;
            }
            return message;
        }
        toObject() {
            const data: {
                min_log_level?: number;
                app_ids?: string[];
                ecu_ids?: string[];
                context_ids?: string[];
                app_id_count?: number;
                context_id_count?: number;
            } = {};
            if (this.min_log_level != null) {
                data.min_log_level = this.min_log_level;
            }
            if (this.app_ids != null) {
                data.app_ids = this.app_ids;
            }
            if (this.ecu_ids != null) {
                data.ecu_ids = this.ecu_ids;
            }
            if (this.context_ids != null) {
                data.context_ids = this.context_ids;
            }
            if (this.app_id_count != null) {
                data.app_id_count = this.app_id_count;
            }
            if (this.context_id_count != null) {
                data.context_id_count = this.context_id_count;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.min_log_level != 0)
                writer.writeUint32(1, this.min_log_level);
            if (this.app_ids.length)
                writer.writeRepeatedString(2, this.app_ids);
            if (this.ecu_ids.length)
                writer.writeRepeatedString(3, this.ecu_ids);
            if (this.context_ids.length)
                writer.writeRepeatedString(4, this.context_ids);
            if (this.app_id_count != 0)
                writer.writeInt64(5, this.app_id_count);
            if (this.context_id_count != 0)
                writer.writeInt64(6, this.context_id_count);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DltFilterConfig {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DltFilterConfig();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.min_log_level = reader.readUint32();
                        break;
                    case 2:
                        pb_1.Message.addToRepeatedField(message, 2, reader.readString());
                        break;
                    case 3:
                        pb_1.Message.addToRepeatedField(message, 3, reader.readString());
                        break;
                    case 4:
                        pb_1.Message.addToRepeatedField(message, 4, reader.readString());
                        break;
                    case 5:
                        message.app_id_count = reader.readInt64();
                        break;
                    case 6:
                        message.context_id_count = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): DltFilterConfig {
            return DltFilterConfig.deserialize(bytes);
        }
    }
    export class SomeIpParserSettings extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            fibex_file_paths?: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("fibex_file_paths" in data && data.fibex_file_paths != undefined) {
                    this.fibex_file_paths = data.fibex_file_paths;
                }
            }
        }
        get fibex_file_paths() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
        }
        set fibex_file_paths(value: string[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            fibex_file_paths?: string[];
        }): SomeIpParserSettings {
            const message = new SomeIpParserSettings({});
            if (data.fibex_file_paths != null) {
                message.fibex_file_paths = data.fibex_file_paths;
            }
            return message;
        }
        toObject() {
            const data: {
                fibex_file_paths?: string[];
            } = {};
            if (this.fibex_file_paths != null) {
                data.fibex_file_paths = this.fibex_file_paths;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.fibex_file_paths.length)
                writer.writeRepeatedString(1, this.fibex_file_paths);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SomeIpParserSettings {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SomeIpParserSettings();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): SomeIpParserSettings {
            return SomeIpParserSettings.deserialize(bytes);
        }
    }
    export class ProcessTransportConfig extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            cwd?: string;
            command?: string;
            envs?: Map<string, string>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("cwd" in data && data.cwd != undefined) {
                    this.cwd = data.cwd;
                }
                if ("command" in data && data.command != undefined) {
                    this.command = data.command;
                }
                if ("envs" in data && data.envs != undefined) {
                    this.envs = data.envs;
                }
            }
            if (!this.envs)
                this.envs = new Map();
        }
        get cwd() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set cwd(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get command() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set command(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get envs() {
            return pb_1.Message.getField(this, 3) as any as Map<string, string>;
        }
        set envs(value: Map<string, string>) {
            pb_1.Message.setField(this, 3, value as any);
        }
        static fromObject(data: {
            cwd?: string;
            command?: string;
            envs?: {
                [key: string]: string;
            };
        }): ProcessTransportConfig {
            const message = new ProcessTransportConfig({});
            if (data.cwd != null) {
                message.cwd = data.cwd;
            }
            if (data.command != null) {
                message.command = data.command;
            }
            if (typeof data.envs == "object") {
                message.envs = new Map(Object.entries(data.envs));
            }
            return message;
        }
        toObject() {
            const data: {
                cwd?: string;
                command?: string;
                envs?: {
                    [key: string]: string;
                };
            } = {};
            if (this.cwd != null) {
                data.cwd = this.cwd;
            }
            if (this.command != null) {
                data.command = this.command;
            }
            if (this.envs != null) {
                data.envs = (Object.fromEntries)(this.envs);
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.cwd.length)
                writer.writeString(1, this.cwd);
            if (this.command.length)
                writer.writeString(2, this.command);
            for (const [key, value] of this.envs) {
                writer.writeMessage(3, this.envs, () => {
                    writer.writeString(1, key);
                    writer.writeString(2, value);
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ProcessTransportConfig {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ProcessTransportConfig();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.cwd = reader.readString();
                        break;
                    case 2:
                        message.command = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.envs as any, reader, reader.readString, reader.readString));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): ProcessTransportConfig {
            return ProcessTransportConfig.deserialize(bytes);
        }
    }
    export class SerialTransportConfig extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            path?: string;
            baud_rate?: number;
            data_bits?: number;
            flow_control?: number;
            parity?: number;
            stop_bits?: number;
            send_data_delay?: number;
            exclusive?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("path" in data && data.path != undefined) {
                    this.path = data.path;
                }
                if ("baud_rate" in data && data.baud_rate != undefined) {
                    this.baud_rate = data.baud_rate;
                }
                if ("data_bits" in data && data.data_bits != undefined) {
                    this.data_bits = data.data_bits;
                }
                if ("flow_control" in data && data.flow_control != undefined) {
                    this.flow_control = data.flow_control;
                }
                if ("parity" in data && data.parity != undefined) {
                    this.parity = data.parity;
                }
                if ("stop_bits" in data && data.stop_bits != undefined) {
                    this.stop_bits = data.stop_bits;
                }
                if ("send_data_delay" in data && data.send_data_delay != undefined) {
                    this.send_data_delay = data.send_data_delay;
                }
                if ("exclusive" in data && data.exclusive != undefined) {
                    this.exclusive = data.exclusive;
                }
            }
        }
        get path() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set path(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get baud_rate() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set baud_rate(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get data_bits() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set data_bits(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get flow_control() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set flow_control(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get parity() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set parity(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get stop_bits() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set stop_bits(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get send_data_delay() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set send_data_delay(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get exclusive() {
            return pb_1.Message.getFieldWithDefault(this, 8, false) as boolean;
        }
        set exclusive(value: boolean) {
            pb_1.Message.setField(this, 8, value);
        }
        static fromObject(data: {
            path?: string;
            baud_rate?: number;
            data_bits?: number;
            flow_control?: number;
            parity?: number;
            stop_bits?: number;
            send_data_delay?: number;
            exclusive?: boolean;
        }): SerialTransportConfig {
            const message = new SerialTransportConfig({});
            if (data.path != null) {
                message.path = data.path;
            }
            if (data.baud_rate != null) {
                message.baud_rate = data.baud_rate;
            }
            if (data.data_bits != null) {
                message.data_bits = data.data_bits;
            }
            if (data.flow_control != null) {
                message.flow_control = data.flow_control;
            }
            if (data.parity != null) {
                message.parity = data.parity;
            }
            if (data.stop_bits != null) {
                message.stop_bits = data.stop_bits;
            }
            if (data.send_data_delay != null) {
                message.send_data_delay = data.send_data_delay;
            }
            if (data.exclusive != null) {
                message.exclusive = data.exclusive;
            }
            return message;
        }
        toObject() {
            const data: {
                path?: string;
                baud_rate?: number;
                data_bits?: number;
                flow_control?: number;
                parity?: number;
                stop_bits?: number;
                send_data_delay?: number;
                exclusive?: boolean;
            } = {};
            if (this.path != null) {
                data.path = this.path;
            }
            if (this.baud_rate != null) {
                data.baud_rate = this.baud_rate;
            }
            if (this.data_bits != null) {
                data.data_bits = this.data_bits;
            }
            if (this.flow_control != null) {
                data.flow_control = this.flow_control;
            }
            if (this.parity != null) {
                data.parity = this.parity;
            }
            if (this.stop_bits != null) {
                data.stop_bits = this.stop_bits;
            }
            if (this.send_data_delay != null) {
                data.send_data_delay = this.send_data_delay;
            }
            if (this.exclusive != null) {
                data.exclusive = this.exclusive;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.path.length)
                writer.writeString(1, this.path);
            if (this.baud_rate != 0)
                writer.writeUint32(2, this.baud_rate);
            if (this.data_bits != 0)
                writer.writeUint32(3, this.data_bits);
            if (this.flow_control != 0)
                writer.writeUint32(4, this.flow_control);
            if (this.parity != 0)
                writer.writeUint32(5, this.parity);
            if (this.stop_bits != 0)
                writer.writeUint32(6, this.stop_bits);
            if (this.send_data_delay != 0)
                writer.writeUint32(7, this.send_data_delay);
            if (this.exclusive != false)
                writer.writeBool(8, this.exclusive);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SerialTransportConfig {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SerialTransportConfig();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.path = reader.readString();
                        break;
                    case 2:
                        message.baud_rate = reader.readUint32();
                        break;
                    case 3:
                        message.data_bits = reader.readUint32();
                        break;
                    case 4:
                        message.flow_control = reader.readUint32();
                        break;
                    case 5:
                        message.parity = reader.readUint32();
                        break;
                    case 6:
                        message.stop_bits = reader.readUint32();
                        break;
                    case 7:
                        message.send_data_delay = reader.readUint32();
                        break;
                    case 8:
                        message.exclusive = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): SerialTransportConfig {
            return SerialTransportConfig.deserialize(bytes);
        }
    }
    export class TCPTransportConfig extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            bind_addr?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("bind_addr" in data && data.bind_addr != undefined) {
                    this.bind_addr = data.bind_addr;
                }
            }
        }
        get bind_addr() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set bind_addr(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            bind_addr?: string;
        }): TCPTransportConfig {
            const message = new TCPTransportConfig({});
            if (data.bind_addr != null) {
                message.bind_addr = data.bind_addr;
            }
            return message;
        }
        toObject() {
            const data: {
                bind_addr?: string;
            } = {};
            if (this.bind_addr != null) {
                data.bind_addr = this.bind_addr;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.bind_addr.length)
                writer.writeString(1, this.bind_addr);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TCPTransportConfig {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TCPTransportConfig();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.bind_addr = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): TCPTransportConfig {
            return TCPTransportConfig.deserialize(bytes);
        }
    }
    export class MulticastInfo extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            multiaddr?: string;
            interface?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("multiaddr" in data && data.multiaddr != undefined) {
                    this.multiaddr = data.multiaddr;
                }
                if ("interface" in data && data.interface != undefined) {
                    this.interface = data.interface;
                }
            }
        }
        get multiaddr() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set multiaddr(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get interface() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set interface(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            multiaddr?: string;
            interface?: string;
        }): MulticastInfo {
            const message = new MulticastInfo({});
            if (data.multiaddr != null) {
                message.multiaddr = data.multiaddr;
            }
            if (data.interface != null) {
                message.interface = data.interface;
            }
            return message;
        }
        toObject() {
            const data: {
                multiaddr?: string;
                interface?: string;
            } = {};
            if (this.multiaddr != null) {
                data.multiaddr = this.multiaddr;
            }
            if (this.interface != null) {
                data.interface = this.interface;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.multiaddr.length)
                writer.writeString(1, this.multiaddr);
            if (this.interface.length)
                writer.writeString(2, this.interface);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MulticastInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MulticastInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.multiaddr = reader.readString();
                        break;
                    case 2:
                        message.interface = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): MulticastInfo {
            return MulticastInfo.deserialize(bytes);
        }
    }
    export class UDPTransportConfig extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            bind_addr?: string;
            multicast?: MulticastInfo[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("bind_addr" in data && data.bind_addr != undefined) {
                    this.bind_addr = data.bind_addr;
                }
                if ("multicast" in data && data.multicast != undefined) {
                    this.multicast = data.multicast;
                }
            }
        }
        get bind_addr() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set bind_addr(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get multicast() {
            return pb_1.Message.getRepeatedWrapperField(this, MulticastInfo, 2) as MulticastInfo[];
        }
        set multicast(value: MulticastInfo[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        static fromObject(data: {
            bind_addr?: string;
            multicast?: ReturnType<typeof MulticastInfo.prototype.toObject>[];
        }): UDPTransportConfig {
            const message = new UDPTransportConfig({});
            if (data.bind_addr != null) {
                message.bind_addr = data.bind_addr;
            }
            if (data.multicast != null) {
                message.multicast = data.multicast.map(item => MulticastInfo.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                bind_addr?: string;
                multicast?: ReturnType<typeof MulticastInfo.prototype.toObject>[];
            } = {};
            if (this.bind_addr != null) {
                data.bind_addr = this.bind_addr;
            }
            if (this.multicast != null) {
                data.multicast = this.multicast.map((item: MulticastInfo) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.bind_addr.length)
                writer.writeString(1, this.bind_addr);
            if (this.multicast.length)
                writer.writeRepeatedMessage(2, this.multicast, (item: MulticastInfo) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UDPTransportConfig {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UDPTransportConfig();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.bind_addr = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.multicast, () => pb_1.Message.addToRepeatedWrapperField(message, 2, MulticastInfo.deserialize(reader), MulticastInfo));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): UDPTransportConfig {
            return UDPTransportConfig.deserialize(bytes);
        }
    }
    export class FileFormat extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): FileFormat {
            const message = new FileFormat({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FileFormat {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FileFormat();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): FileFormat {
            return FileFormat.deserialize(bytes);
        }
    }
    export namespace FileFormat {
        export enum Type {
            PcapNG = 0,
            PcapLegacy = 1,
            Text = 2,
            Binary = 3
        }
    }
    export class ParserType extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2, 3]];
        constructor(data?: any[] | ({} & (({
            dlt?: DltParserSettings;
            some_ip?: never;
            text?: never;
        } | {
            dlt?: never;
            some_ip?: SomeIpParserSettings;
            text?: never;
        } | {
            dlt?: never;
            some_ip?: never;
            text?: boolean;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("dlt" in data && data.dlt != undefined) {
                    this.dlt = data.dlt;
                }
                if ("some_ip" in data && data.some_ip != undefined) {
                    this.some_ip = data.some_ip;
                }
                if ("text" in data && data.text != undefined) {
                    this.text = data.text;
                }
            }
        }
        get dlt() {
            return pb_1.Message.getWrapperField(this, DltParserSettings, 1) as DltParserSettings;
        }
        set dlt(value: DltParserSettings) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_dlt() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get some_ip() {
            return pb_1.Message.getWrapperField(this, SomeIpParserSettings, 2) as SomeIpParserSettings;
        }
        set some_ip(value: SomeIpParserSettings) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_some_ip() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get text() {
            return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
        }
        set text(value: boolean) {
            pb_1.Message.setOneofField(this, 3, this.#one_of_decls[0], value);
        }
        get has_text() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get type() {
            const cases: {
                [index: number]: "none" | "dlt" | "some_ip" | "text";
            } = {
                0: "none",
                1: "dlt",
                2: "some_ip",
                3: "text"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3])];
        }
        static fromObject(data: {
            dlt?: ReturnType<typeof DltParserSettings.prototype.toObject>;
            some_ip?: ReturnType<typeof SomeIpParserSettings.prototype.toObject>;
            text?: boolean;
        }): ParserType {
            const message = new ParserType({});
            if (data.dlt != null) {
                message.dlt = DltParserSettings.fromObject(data.dlt);
            }
            if (data.some_ip != null) {
                message.some_ip = SomeIpParserSettings.fromObject(data.some_ip);
            }
            if (data.text != null) {
                message.text = data.text;
            }
            return message;
        }
        toObject() {
            const data: {
                dlt?: ReturnType<typeof DltParserSettings.prototype.toObject>;
                some_ip?: ReturnType<typeof SomeIpParserSettings.prototype.toObject>;
                text?: boolean;
            } = {};
            if (this.dlt != null) {
                data.dlt = this.dlt.toObject();
            }
            if (this.some_ip != null) {
                data.some_ip = this.some_ip.toObject();
            }
            if (this.text != null) {
                data.text = this.text;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_dlt)
                writer.writeMessage(1, this.dlt, () => this.dlt.serialize(writer));
            if (this.has_some_ip)
                writer.writeMessage(2, this.some_ip, () => this.some_ip.serialize(writer));
            if (this.has_text)
                writer.writeBool(3, this.text);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ParserType {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ParserType();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.dlt, () => message.dlt = DltParserSettings.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.some_ip, () => message.some_ip = SomeIpParserSettings.deserialize(reader));
                        break;
                    case 3:
                        message.text = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): ParserType {
            return ParserType.deserialize(bytes);
        }
    }
    export class Transport extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2, 3, 4]];
        constructor(data?: any[] | ({} & (({
            process?: ProcessTransportConfig;
            tcp?: never;
            udp?: never;
            serial?: never;
        } | {
            process?: never;
            tcp?: TCPTransportConfig;
            udp?: never;
            serial?: never;
        } | {
            process?: never;
            tcp?: never;
            udp?: UDPTransportConfig;
            serial?: never;
        } | {
            process?: never;
            tcp?: never;
            udp?: never;
            serial?: SerialTransportConfig;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("process" in data && data.process != undefined) {
                    this.process = data.process;
                }
                if ("tcp" in data && data.tcp != undefined) {
                    this.tcp = data.tcp;
                }
                if ("udp" in data && data.udp != undefined) {
                    this.udp = data.udp;
                }
                if ("serial" in data && data.serial != undefined) {
                    this.serial = data.serial;
                }
            }
        }
        get process() {
            return pb_1.Message.getWrapperField(this, ProcessTransportConfig, 1) as ProcessTransportConfig;
        }
        set process(value: ProcessTransportConfig) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_process() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get tcp() {
            return pb_1.Message.getWrapperField(this, TCPTransportConfig, 2) as TCPTransportConfig;
        }
        set tcp(value: TCPTransportConfig) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_tcp() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get udp() {
            return pb_1.Message.getWrapperField(this, UDPTransportConfig, 3) as UDPTransportConfig;
        }
        set udp(value: UDPTransportConfig) {
            pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
        }
        get has_udp() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get serial() {
            return pb_1.Message.getWrapperField(this, SerialTransportConfig, 4) as SerialTransportConfig;
        }
        set serial(value: SerialTransportConfig) {
            pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
        }
        get has_serial() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get transport() {
            const cases: {
                [index: number]: "none" | "process" | "tcp" | "udp" | "serial";
            } = {
                0: "none",
                1: "process",
                2: "tcp",
                3: "udp",
                4: "serial"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4])];
        }
        static fromObject(data: {
            process?: ReturnType<typeof ProcessTransportConfig.prototype.toObject>;
            tcp?: ReturnType<typeof TCPTransportConfig.prototype.toObject>;
            udp?: ReturnType<typeof UDPTransportConfig.prototype.toObject>;
            serial?: ReturnType<typeof SerialTransportConfig.prototype.toObject>;
        }): Transport {
            const message = new Transport({});
            if (data.process != null) {
                message.process = ProcessTransportConfig.fromObject(data.process);
            }
            if (data.tcp != null) {
                message.tcp = TCPTransportConfig.fromObject(data.tcp);
            }
            if (data.udp != null) {
                message.udp = UDPTransportConfig.fromObject(data.udp);
            }
            if (data.serial != null) {
                message.serial = SerialTransportConfig.fromObject(data.serial);
            }
            return message;
        }
        toObject() {
            const data: {
                process?: ReturnType<typeof ProcessTransportConfig.prototype.toObject>;
                tcp?: ReturnType<typeof TCPTransportConfig.prototype.toObject>;
                udp?: ReturnType<typeof UDPTransportConfig.prototype.toObject>;
                serial?: ReturnType<typeof SerialTransportConfig.prototype.toObject>;
            } = {};
            if (this.process != null) {
                data.process = this.process.toObject();
            }
            if (this.tcp != null) {
                data.tcp = this.tcp.toObject();
            }
            if (this.udp != null) {
                data.udp = this.udp.toObject();
            }
            if (this.serial != null) {
                data.serial = this.serial.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_process)
                writer.writeMessage(1, this.process, () => this.process.serialize(writer));
            if (this.has_tcp)
                writer.writeMessage(2, this.tcp, () => this.tcp.serialize(writer));
            if (this.has_udp)
                writer.writeMessage(3, this.udp, () => this.udp.serialize(writer));
            if (this.has_serial)
                writer.writeMessage(4, this.serial, () => this.serial.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Transport {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Transport();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.process, () => message.process = ProcessTransportConfig.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.tcp, () => message.tcp = TCPTransportConfig.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.udp, () => message.udp = UDPTransportConfig.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.serial, () => message.serial = SerialTransportConfig.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): Transport {
            return Transport.deserialize(bytes);
        }
    }
    export class ObserveOrigin extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2, 3]];
        constructor(data?: any[] | ({} & (({
            file?: ObserveOrigin.File;
            concat?: never;
            stream?: never;
        } | {
            file?: never;
            concat?: ObserveOrigin.Concat;
            stream?: never;
        } | {
            file?: never;
            concat?: never;
            stream?: ObserveOrigin.Stream;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("file" in data && data.file != undefined) {
                    this.file = data.file;
                }
                if ("concat" in data && data.concat != undefined) {
                    this.concat = data.concat;
                }
                if ("stream" in data && data.stream != undefined) {
                    this.stream = data.stream;
                }
            }
        }
        get file() {
            return pb_1.Message.getWrapperField(this, ObserveOrigin.File, 1) as ObserveOrigin.File;
        }
        set file(value: ObserveOrigin.File) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_file() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get concat() {
            return pb_1.Message.getWrapperField(this, ObserveOrigin.Concat, 2) as ObserveOrigin.Concat;
        }
        set concat(value: ObserveOrigin.Concat) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_concat() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get stream() {
            return pb_1.Message.getWrapperField(this, ObserveOrigin.Stream, 3) as ObserveOrigin.Stream;
        }
        set stream(value: ObserveOrigin.Stream) {
            pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
        }
        get has_stream() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get origin() {
            const cases: {
                [index: number]: "none" | "file" | "concat" | "stream";
            } = {
                0: "none",
                1: "file",
                2: "concat",
                3: "stream"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3])];
        }
        static fromObject(data: {
            file?: ReturnType<typeof ObserveOrigin.File.prototype.toObject>;
            concat?: ReturnType<typeof ObserveOrigin.Concat.prototype.toObject>;
            stream?: ReturnType<typeof ObserveOrigin.Stream.prototype.toObject>;
        }): ObserveOrigin {
            const message = new ObserveOrigin({});
            if (data.file != null) {
                message.file = ObserveOrigin.File.fromObject(data.file);
            }
            if (data.concat != null) {
                message.concat = ObserveOrigin.Concat.fromObject(data.concat);
            }
            if (data.stream != null) {
                message.stream = ObserveOrigin.Stream.fromObject(data.stream);
            }
            return message;
        }
        toObject() {
            const data: {
                file?: ReturnType<typeof ObserveOrigin.File.prototype.toObject>;
                concat?: ReturnType<typeof ObserveOrigin.Concat.prototype.toObject>;
                stream?: ReturnType<typeof ObserveOrigin.Stream.prototype.toObject>;
            } = {};
            if (this.file != null) {
                data.file = this.file.toObject();
            }
            if (this.concat != null) {
                data.concat = this.concat.toObject();
            }
            if (this.stream != null) {
                data.stream = this.stream.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_file)
                writer.writeMessage(1, this.file, () => this.file.serialize(writer));
            if (this.has_concat)
                writer.writeMessage(2, this.concat, () => this.concat.serialize(writer));
            if (this.has_stream)
                writer.writeMessage(3, this.stream, () => this.stream.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ObserveOrigin {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ObserveOrigin();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.file, () => message.file = ObserveOrigin.File.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.concat, () => message.concat = ObserveOrigin.Concat.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.stream, () => message.stream = ObserveOrigin.Stream.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): ObserveOrigin {
            return ObserveOrigin.deserialize(bytes);
        }
    }
    export namespace ObserveOrigin {
        export class File extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                name?: string;
                format?: FileFormat.Type;
                path?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("name" in data && data.name != undefined) {
                        this.name = data.name;
                    }
                    if ("format" in data && data.format != undefined) {
                        this.format = data.format;
                    }
                    if ("path" in data && data.path != undefined) {
                        this.path = data.path;
                    }
                }
            }
            get name() {
                return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
            }
            set name(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get format() {
                return pb_1.Message.getFieldWithDefault(this, 2, FileFormat.Type.PcapNG) as FileFormat.Type;
            }
            set format(value: FileFormat.Type) {
                pb_1.Message.setField(this, 2, value);
            }
            get path() {
                return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
            }
            set path(value: string) {
                pb_1.Message.setField(this, 3, value);
            }
            static fromObject(data: {
                name?: string;
                format?: FileFormat.Type;
                path?: string;
            }): File {
                const message = new File({});
                if (data.name != null) {
                    message.name = data.name;
                }
                if (data.format != null) {
                    message.format = data.format;
                }
                if (data.path != null) {
                    message.path = data.path;
                }
                return message;
            }
            toObject() {
                const data: {
                    name?: string;
                    format?: FileFormat.Type;
                    path?: string;
                } = {};
                if (this.name != null) {
                    data.name = this.name;
                }
                if (this.format != null) {
                    data.format = this.format;
                }
                if (this.path != null) {
                    data.path = this.path;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.name.length)
                    writer.writeString(1, this.name);
                if (this.format != FileFormat.Type.PcapNG)
                    writer.writeEnum(2, this.format);
                if (this.path.length)
                    writer.writeString(3, this.path);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): File {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new File();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.name = reader.readString();
                            break;
                        case 2:
                            message.format = reader.readEnum();
                            break;
                        case 3:
                            message.path = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static override deserializeBinary(bytes: Uint8Array): File {
                return File.deserialize(bytes);
            }
        }
        export class Concat extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                files?: ObserveOrigin.File[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("files" in data && data.files != undefined) {
                        this.files = data.files;
                    }
                }
            }
            get files() {
                return pb_1.Message.getRepeatedWrapperField(this, ObserveOrigin.File, 1) as ObserveOrigin.File[];
            }
            set files(value: ObserveOrigin.File[]) {
                pb_1.Message.setRepeatedWrapperField(this, 1, value);
            }
            static fromObject(data: {
                files?: ReturnType<typeof ObserveOrigin.File.prototype.toObject>[];
            }): Concat {
                const message = new Concat({});
                if (data.files != null) {
                    message.files = data.files.map(item => ObserveOrigin.File.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data: {
                    files?: ReturnType<typeof ObserveOrigin.File.prototype.toObject>[];
                } = {};
                if (this.files != null) {
                    data.files = this.files.map((item: ObserveOrigin.File) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.files.length)
                    writer.writeRepeatedMessage(1, this.files, (item: ObserveOrigin.File) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Concat {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Concat();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.files, () => pb_1.Message.addToRepeatedWrapperField(message, 1, ObserveOrigin.File.deserialize(reader), ObserveOrigin.File));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static override deserializeBinary(bytes: Uint8Array): Concat {
                return Concat.deserialize(bytes);
            }
        }
        export class Stream extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                name?: string;
                transport?: Transport;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("name" in data && data.name != undefined) {
                        this.name = data.name;
                    }
                    if ("transport" in data && data.transport != undefined) {
                        this.transport = data.transport;
                    }
                }
            }
            get name() {
                return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
            }
            set name(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get transport() {
                return pb_1.Message.getWrapperField(this, Transport, 2) as Transport;
            }
            set transport(value: Transport) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_transport() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                name?: string;
                transport?: ReturnType<typeof Transport.prototype.toObject>;
            }): Stream {
                const message = new Stream({});
                if (data.name != null) {
                    message.name = data.name;
                }
                if (data.transport != null) {
                    message.transport = Transport.fromObject(data.transport);
                }
                return message;
            }
            toObject() {
                const data: {
                    name?: string;
                    transport?: ReturnType<typeof Transport.prototype.toObject>;
                } = {};
                if (this.name != null) {
                    data.name = this.name;
                }
                if (this.transport != null) {
                    data.transport = this.transport.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.name.length)
                    writer.writeString(1, this.name);
                if (this.has_transport)
                    writer.writeMessage(2, this.transport, () => this.transport.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Stream {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Stream();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.name = reader.readString();
                            break;
                        case 2:
                            reader.readMessage(message.transport, () => message.transport = Transport.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static override deserializeBinary(bytes: Uint8Array): Stream {
                return Stream.deserialize(bytes);
            }
        }
    }
}
