/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 5.27.2
 * source: event.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./error";
import * as dependency_2 from "./attachment";
import * as pb_1 from "google-protobuf";
export namespace event {
    export class OperationDone extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            uuid?: string;
            result?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("uuid" in data && data.uuid != undefined) {
                    this.uuid = data.uuid;
                }
                if ("result" in data && data.result != undefined) {
                    this.result = data.result;
                }
            }
        }
        get uuid() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set uuid(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get result() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set result(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            uuid?: string;
            result?: string;
        }): OperationDone {
            const message = new OperationDone({});
            if (data.uuid != null) {
                message.uuid = data.uuid;
            }
            if (data.result != null) {
                message.result = data.result;
            }
            return message;
        }
        toObject() {
            const data: {
                uuid?: string;
                result?: string;
            } = {};
            if (this.uuid != null) {
                data.uuid = this.uuid;
            }
            if (this.result != null) {
                data.result = this.result;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.uuid.length)
                writer.writeString(1, this.uuid);
            if (this.result.length)
                writer.writeString(2, this.result);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OperationDone {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OperationDone();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.uuid = reader.readString();
                        break;
                    case 2:
                        message.result = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): OperationDone {
            return OperationDone.deserialize(bytes);
        }
    }
    export class Ticks extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            count?: number;
            state?: string;
            total?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("count" in data && data.count != undefined) {
                    this.count = data.count;
                }
                if ("state" in data && data.state != undefined) {
                    this.state = data.state;
                }
                if ("total" in data && data.total != undefined) {
                    this.total = data.total;
                }
            }
        }
        get count() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set count(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get state() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set state(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get total() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set total(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            count?: number;
            state?: string;
            total?: number;
        }): Ticks {
            const message = new Ticks({});
            if (data.count != null) {
                message.count = data.count;
            }
            if (data.state != null) {
                message.state = data.state;
            }
            if (data.total != null) {
                message.total = data.total;
            }
            return message;
        }
        toObject() {
            const data: {
                count?: number;
                state?: string;
                total?: number;
            } = {};
            if (this.count != null) {
                data.count = this.count;
            }
            if (this.state != null) {
                data.state = this.state;
            }
            if (this.total != null) {
                data.total = this.total;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.count != 0)
                writer.writeUint64(1, this.count);
            if (this.state.length)
                writer.writeString(2, this.state);
            if (this.total != 0)
                writer.writeUint64(3, this.total);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Ticks {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Ticks();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.count = reader.readUint64();
                        break;
                    case 2:
                        message.state = reader.readString();
                        break;
                    case 3:
                        message.total = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): Ticks {
            return Ticks.deserialize(bytes);
        }
    }
    export class Notification extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            severity?: dependency_1.error.Severity;
            content?: string;
            line?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("severity" in data && data.severity != undefined) {
                    this.severity = data.severity;
                }
                if ("content" in data && data.content != undefined) {
                    this.content = data.content;
                }
                if ("line" in data && data.line != undefined) {
                    this.line = data.line;
                }
            }
        }
        get severity() {
            return pb_1.Message.getFieldWithDefault(this, 1, dependency_1.error.Severity.WARNING) as dependency_1.error.Severity;
        }
        set severity(value: dependency_1.error.Severity) {
            pb_1.Message.setField(this, 1, value);
        }
        get content() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set content(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get line() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set line(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            severity?: dependency_1.error.Severity;
            content?: string;
            line?: number;
        }): Notification {
            const message = new Notification({});
            if (data.severity != null) {
                message.severity = data.severity;
            }
            if (data.content != null) {
                message.content = data.content;
            }
            if (data.line != null) {
                message.line = data.line;
            }
            return message;
        }
        toObject() {
            const data: {
                severity?: dependency_1.error.Severity;
                content?: string;
                line?: number;
            } = {};
            if (this.severity != null) {
                data.severity = this.severity;
            }
            if (this.content != null) {
                data.content = this.content;
            }
            if (this.line != null) {
                data.line = this.line;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.severity != dependency_1.error.Severity.WARNING)
                writer.writeEnum(1, this.severity);
            if (this.content.length)
                writer.writeString(2, this.content);
            if (this.line != 0)
                writer.writeUint64(3, this.line);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Notification {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Notification();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.severity = reader.readEnum();
                        break;
                    case 2:
                        message.content = reader.readString();
                        break;
                    case 3:
                        message.line = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): Notification {
            return Notification.deserialize(bytes);
        }
    }
    export class CallbackEvent extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]];
        constructor(data?: any[] | ({} & (({
            stream_updated?: number;
            file_read?: never;
            search_updated?: never;
            indexed_map_updated?: never;
            search_map_updated?: never;
            search_values_updated?: never;
            attachments_updated?: never;
            progress?: never;
            session_error?: never;
            operation_error?: never;
            operation_started?: never;
            operation_processing?: never;
            operation_done?: never;
            session_destroyed?: never;
        } | {
            stream_updated?: never;
            file_read?: boolean;
            search_updated?: never;
            indexed_map_updated?: never;
            search_map_updated?: never;
            search_values_updated?: never;
            attachments_updated?: never;
            progress?: never;
            session_error?: never;
            operation_error?: never;
            operation_started?: never;
            operation_processing?: never;
            operation_done?: never;
            session_destroyed?: never;
        } | {
            stream_updated?: never;
            file_read?: never;
            search_updated?: CallbackEvent.SearchUpdated;
            indexed_map_updated?: never;
            search_map_updated?: never;
            search_values_updated?: never;
            attachments_updated?: never;
            progress?: never;
            session_error?: never;
            operation_error?: never;
            operation_started?: never;
            operation_processing?: never;
            operation_done?: never;
            session_destroyed?: never;
        } | {
            stream_updated?: never;
            file_read?: never;
            search_updated?: never;
            indexed_map_updated?: CallbackEvent.IndexedMapUpdated;
            search_map_updated?: never;
            search_values_updated?: never;
            attachments_updated?: never;
            progress?: never;
            session_error?: never;
            operation_error?: never;
            operation_started?: never;
            operation_processing?: never;
            operation_done?: never;
            session_destroyed?: never;
        } | {
            stream_updated?: never;
            file_read?: never;
            search_updated?: never;
            indexed_map_updated?: never;
            search_map_updated?: CallbackEvent.SearchMapUpdated;
            search_values_updated?: never;
            attachments_updated?: never;
            progress?: never;
            session_error?: never;
            operation_error?: never;
            operation_started?: never;
            operation_processing?: never;
            operation_done?: never;
            session_destroyed?: never;
        } | {
            stream_updated?: never;
            file_read?: never;
            search_updated?: never;
            indexed_map_updated?: never;
            search_map_updated?: never;
            search_values_updated?: CallbackEvent.SearchValuesUpdated;
            attachments_updated?: never;
            progress?: never;
            session_error?: never;
            operation_error?: never;
            operation_started?: never;
            operation_processing?: never;
            operation_done?: never;
            session_destroyed?: never;
        } | {
            stream_updated?: never;
            file_read?: never;
            search_updated?: never;
            indexed_map_updated?: never;
            search_map_updated?: never;
            search_values_updated?: never;
            attachments_updated?: CallbackEvent.AttachmentsUpdated;
            progress?: never;
            session_error?: never;
            operation_error?: never;
            operation_started?: never;
            operation_processing?: never;
            operation_done?: never;
            session_destroyed?: never;
        } | {
            stream_updated?: never;
            file_read?: never;
            search_updated?: never;
            indexed_map_updated?: never;
            search_map_updated?: never;
            search_values_updated?: never;
            attachments_updated?: never;
            progress?: CallbackEvent.Progress;
            session_error?: never;
            operation_error?: never;
            operation_started?: never;
            operation_processing?: never;
            operation_done?: never;
            session_destroyed?: never;
        } | {
            stream_updated?: never;
            file_read?: never;
            search_updated?: never;
            indexed_map_updated?: never;
            search_map_updated?: never;
            search_values_updated?: never;
            attachments_updated?: never;
            progress?: never;
            session_error?: dependency_1.error.NativeError;
            operation_error?: never;
            operation_started?: never;
            operation_processing?: never;
            operation_done?: never;
            session_destroyed?: never;
        } | {
            stream_updated?: never;
            file_read?: never;
            search_updated?: never;
            indexed_map_updated?: never;
            search_map_updated?: never;
            search_values_updated?: never;
            attachments_updated?: never;
            progress?: never;
            session_error?: never;
            operation_error?: CallbackEvent.OperationError;
            operation_started?: never;
            operation_processing?: never;
            operation_done?: never;
            session_destroyed?: never;
        } | {
            stream_updated?: never;
            file_read?: never;
            search_updated?: never;
            indexed_map_updated?: never;
            search_map_updated?: never;
            search_values_updated?: never;
            attachments_updated?: never;
            progress?: never;
            session_error?: never;
            operation_error?: never;
            operation_started?: string;
            operation_processing?: never;
            operation_done?: never;
            session_destroyed?: never;
        } | {
            stream_updated?: never;
            file_read?: never;
            search_updated?: never;
            indexed_map_updated?: never;
            search_map_updated?: never;
            search_values_updated?: never;
            attachments_updated?: never;
            progress?: never;
            session_error?: never;
            operation_error?: never;
            operation_started?: never;
            operation_processing?: string;
            operation_done?: never;
            session_destroyed?: never;
        } | {
            stream_updated?: never;
            file_read?: never;
            search_updated?: never;
            indexed_map_updated?: never;
            search_map_updated?: never;
            search_values_updated?: never;
            attachments_updated?: never;
            progress?: never;
            session_error?: never;
            operation_error?: never;
            operation_started?: never;
            operation_processing?: never;
            operation_done?: OperationDone;
            session_destroyed?: never;
        } | {
            stream_updated?: never;
            file_read?: never;
            search_updated?: never;
            indexed_map_updated?: never;
            search_map_updated?: never;
            search_values_updated?: never;
            attachments_updated?: never;
            progress?: never;
            session_error?: never;
            operation_error?: never;
            operation_started?: never;
            operation_processing?: never;
            operation_done?: never;
            session_destroyed?: boolean;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("stream_updated" in data && data.stream_updated != undefined) {
                    this.stream_updated = data.stream_updated;
                }
                if ("file_read" in data && data.file_read != undefined) {
                    this.file_read = data.file_read;
                }
                if ("search_updated" in data && data.search_updated != undefined) {
                    this.search_updated = data.search_updated;
                }
                if ("indexed_map_updated" in data && data.indexed_map_updated != undefined) {
                    this.indexed_map_updated = data.indexed_map_updated;
                }
                if ("search_map_updated" in data && data.search_map_updated != undefined) {
                    this.search_map_updated = data.search_map_updated;
                }
                if ("search_values_updated" in data && data.search_values_updated != undefined) {
                    this.search_values_updated = data.search_values_updated;
                }
                if ("attachments_updated" in data && data.attachments_updated != undefined) {
                    this.attachments_updated = data.attachments_updated;
                }
                if ("progress" in data && data.progress != undefined) {
                    this.progress = data.progress;
                }
                if ("session_error" in data && data.session_error != undefined) {
                    this.session_error = data.session_error;
                }
                if ("operation_error" in data && data.operation_error != undefined) {
                    this.operation_error = data.operation_error;
                }
                if ("operation_started" in data && data.operation_started != undefined) {
                    this.operation_started = data.operation_started;
                }
                if ("operation_processing" in data && data.operation_processing != undefined) {
                    this.operation_processing = data.operation_processing;
                }
                if ("operation_done" in data && data.operation_done != undefined) {
                    this.operation_done = data.operation_done;
                }
                if ("session_destroyed" in data && data.session_destroyed != undefined) {
                    this.session_destroyed = data.session_destroyed;
                }
            }
        }
        get stream_updated() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set stream_updated(value: number) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_stream_updated() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get file_read() {
            return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
        }
        set file_read(value: boolean) {
            pb_1.Message.setOneofField(this, 2, this.#one_of_decls[0], value);
        }
        get has_file_read() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get search_updated() {
            return pb_1.Message.getWrapperField(this, CallbackEvent.SearchUpdated, 3) as CallbackEvent.SearchUpdated;
        }
        set search_updated(value: CallbackEvent.SearchUpdated) {
            pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
        }
        get has_search_updated() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get indexed_map_updated() {
            return pb_1.Message.getWrapperField(this, CallbackEvent.IndexedMapUpdated, 4) as CallbackEvent.IndexedMapUpdated;
        }
        set indexed_map_updated(value: CallbackEvent.IndexedMapUpdated) {
            pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
        }
        get has_indexed_map_updated() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get search_map_updated() {
            return pb_1.Message.getWrapperField(this, CallbackEvent.SearchMapUpdated, 5) as CallbackEvent.SearchMapUpdated;
        }
        set search_map_updated(value: CallbackEvent.SearchMapUpdated) {
            pb_1.Message.setOneofWrapperField(this, 5, this.#one_of_decls[0], value);
        }
        get has_search_map_updated() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get search_values_updated() {
            return pb_1.Message.getWrapperField(this, CallbackEvent.SearchValuesUpdated, 6) as CallbackEvent.SearchValuesUpdated;
        }
        set search_values_updated(value: CallbackEvent.SearchValuesUpdated) {
            pb_1.Message.setOneofWrapperField(this, 6, this.#one_of_decls[0], value);
        }
        get has_search_values_updated() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get attachments_updated() {
            return pb_1.Message.getWrapperField(this, CallbackEvent.AttachmentsUpdated, 7) as CallbackEvent.AttachmentsUpdated;
        }
        set attachments_updated(value: CallbackEvent.AttachmentsUpdated) {
            pb_1.Message.setOneofWrapperField(this, 7, this.#one_of_decls[0], value);
        }
        get has_attachments_updated() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get progress() {
            return pb_1.Message.getWrapperField(this, CallbackEvent.Progress, 8) as CallbackEvent.Progress;
        }
        set progress(value: CallbackEvent.Progress) {
            pb_1.Message.setOneofWrapperField(this, 8, this.#one_of_decls[0], value);
        }
        get has_progress() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get session_error() {
            return pb_1.Message.getWrapperField(this, dependency_1.error.NativeError, 9) as dependency_1.error.NativeError;
        }
        set session_error(value: dependency_1.error.NativeError) {
            pb_1.Message.setOneofWrapperField(this, 9, this.#one_of_decls[0], value);
        }
        get has_session_error() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get operation_error() {
            return pb_1.Message.getWrapperField(this, CallbackEvent.OperationError, 10) as CallbackEvent.OperationError;
        }
        set operation_error(value: CallbackEvent.OperationError) {
            pb_1.Message.setOneofWrapperField(this, 10, this.#one_of_decls[0], value);
        }
        get has_operation_error() {
            return pb_1.Message.getField(this, 10) != null;
        }
        get operation_started() {
            return pb_1.Message.getFieldWithDefault(this, 11, "") as string;
        }
        set operation_started(value: string) {
            pb_1.Message.setOneofField(this, 11, this.#one_of_decls[0], value);
        }
        get has_operation_started() {
            return pb_1.Message.getField(this, 11) != null;
        }
        get operation_processing() {
            return pb_1.Message.getFieldWithDefault(this, 12, "") as string;
        }
        set operation_processing(value: string) {
            pb_1.Message.setOneofField(this, 12, this.#one_of_decls[0], value);
        }
        get has_operation_processing() {
            return pb_1.Message.getField(this, 12) != null;
        }
        get operation_done() {
            return pb_1.Message.getWrapperField(this, OperationDone, 13) as OperationDone;
        }
        set operation_done(value: OperationDone) {
            pb_1.Message.setOneofWrapperField(this, 13, this.#one_of_decls[0], value);
        }
        get has_operation_done() {
            return pb_1.Message.getField(this, 13) != null;
        }
        get session_destroyed() {
            return pb_1.Message.getFieldWithDefault(this, 14, false) as boolean;
        }
        set session_destroyed(value: boolean) {
            pb_1.Message.setOneofField(this, 14, this.#one_of_decls[0], value);
        }
        get has_session_destroyed() {
            return pb_1.Message.getField(this, 14) != null;
        }
        get event() {
            const cases: {
                [index: number]: "none" | "stream_updated" | "file_read" | "search_updated" | "indexed_map_updated" | "search_map_updated" | "search_values_updated" | "attachments_updated" | "progress" | "session_error" | "operation_error" | "operation_started" | "operation_processing" | "operation_done" | "session_destroyed";
            } = {
                0: "none",
                1: "stream_updated",
                2: "file_read",
                3: "search_updated",
                4: "indexed_map_updated",
                5: "search_map_updated",
                6: "search_values_updated",
                7: "attachments_updated",
                8: "progress",
                9: "session_error",
                10: "operation_error",
                11: "operation_started",
                12: "operation_processing",
                13: "operation_done",
                14: "session_destroyed"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])];
        }
        static fromObject(data: {
            stream_updated?: number;
            file_read?: boolean;
            search_updated?: ReturnType<typeof CallbackEvent.SearchUpdated.prototype.toObject>;
            indexed_map_updated?: ReturnType<typeof CallbackEvent.IndexedMapUpdated.prototype.toObject>;
            search_map_updated?: ReturnType<typeof CallbackEvent.SearchMapUpdated.prototype.toObject>;
            search_values_updated?: ReturnType<typeof CallbackEvent.SearchValuesUpdated.prototype.toObject>;
            attachments_updated?: ReturnType<typeof CallbackEvent.AttachmentsUpdated.prototype.toObject>;
            progress?: ReturnType<typeof CallbackEvent.Progress.prototype.toObject>;
            session_error?: ReturnType<typeof dependency_1.error.NativeError.prototype.toObject>;
            operation_error?: ReturnType<typeof CallbackEvent.OperationError.prototype.toObject>;
            operation_started?: string;
            operation_processing?: string;
            operation_done?: ReturnType<typeof OperationDone.prototype.toObject>;
            session_destroyed?: boolean;
        }): CallbackEvent {
            const message = new CallbackEvent({});
            if (data.stream_updated != null) {
                message.stream_updated = data.stream_updated;
            }
            if (data.file_read != null) {
                message.file_read = data.file_read;
            }
            if (data.search_updated != null) {
                message.search_updated = CallbackEvent.SearchUpdated.fromObject(data.search_updated);
            }
            if (data.indexed_map_updated != null) {
                message.indexed_map_updated = CallbackEvent.IndexedMapUpdated.fromObject(data.indexed_map_updated);
            }
            if (data.search_map_updated != null) {
                message.search_map_updated = CallbackEvent.SearchMapUpdated.fromObject(data.search_map_updated);
            }
            if (data.search_values_updated != null) {
                message.search_values_updated = CallbackEvent.SearchValuesUpdated.fromObject(data.search_values_updated);
            }
            if (data.attachments_updated != null) {
                message.attachments_updated = CallbackEvent.AttachmentsUpdated.fromObject(data.attachments_updated);
            }
            if (data.progress != null) {
                message.progress = CallbackEvent.Progress.fromObject(data.progress);
            }
            if (data.session_error != null) {
                message.session_error = dependency_1.error.NativeError.fromObject(data.session_error);
            }
            if (data.operation_error != null) {
                message.operation_error = CallbackEvent.OperationError.fromObject(data.operation_error);
            }
            if (data.operation_started != null) {
                message.operation_started = data.operation_started;
            }
            if (data.operation_processing != null) {
                message.operation_processing = data.operation_processing;
            }
            if (data.operation_done != null) {
                message.operation_done = OperationDone.fromObject(data.operation_done);
            }
            if (data.session_destroyed != null) {
                message.session_destroyed = data.session_destroyed;
            }
            return message;
        }
        toObject() {
            const data: {
                stream_updated?: number;
                file_read?: boolean;
                search_updated?: ReturnType<typeof CallbackEvent.SearchUpdated.prototype.toObject>;
                indexed_map_updated?: ReturnType<typeof CallbackEvent.IndexedMapUpdated.prototype.toObject>;
                search_map_updated?: ReturnType<typeof CallbackEvent.SearchMapUpdated.prototype.toObject>;
                search_values_updated?: ReturnType<typeof CallbackEvent.SearchValuesUpdated.prototype.toObject>;
                attachments_updated?: ReturnType<typeof CallbackEvent.AttachmentsUpdated.prototype.toObject>;
                progress?: ReturnType<typeof CallbackEvent.Progress.prototype.toObject>;
                session_error?: ReturnType<typeof dependency_1.error.NativeError.prototype.toObject>;
                operation_error?: ReturnType<typeof CallbackEvent.OperationError.prototype.toObject>;
                operation_started?: string;
                operation_processing?: string;
                operation_done?: ReturnType<typeof OperationDone.prototype.toObject>;
                session_destroyed?: boolean;
            } = {};
            if (this.stream_updated != null) {
                data.stream_updated = this.stream_updated;
            }
            if (this.file_read != null) {
                data.file_read = this.file_read;
            }
            if (this.search_updated != null) {
                data.search_updated = this.search_updated.toObject();
            }
            if (this.indexed_map_updated != null) {
                data.indexed_map_updated = this.indexed_map_updated.toObject();
            }
            if (this.search_map_updated != null) {
                data.search_map_updated = this.search_map_updated.toObject();
            }
            if (this.search_values_updated != null) {
                data.search_values_updated = this.search_values_updated.toObject();
            }
            if (this.attachments_updated != null) {
                data.attachments_updated = this.attachments_updated.toObject();
            }
            if (this.progress != null) {
                data.progress = this.progress.toObject();
            }
            if (this.session_error != null) {
                data.session_error = this.session_error.toObject();
            }
            if (this.operation_error != null) {
                data.operation_error = this.operation_error.toObject();
            }
            if (this.operation_started != null) {
                data.operation_started = this.operation_started;
            }
            if (this.operation_processing != null) {
                data.operation_processing = this.operation_processing;
            }
            if (this.operation_done != null) {
                data.operation_done = this.operation_done.toObject();
            }
            if (this.session_destroyed != null) {
                data.session_destroyed = this.session_destroyed;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_stream_updated)
                writer.writeUint64(1, this.stream_updated);
            if (this.has_file_read)
                writer.writeBool(2, this.file_read);
            if (this.has_search_updated)
                writer.writeMessage(3, this.search_updated, () => this.search_updated.serialize(writer));
            if (this.has_indexed_map_updated)
                writer.writeMessage(4, this.indexed_map_updated, () => this.indexed_map_updated.serialize(writer));
            if (this.has_search_map_updated)
                writer.writeMessage(5, this.search_map_updated, () => this.search_map_updated.serialize(writer));
            if (this.has_search_values_updated)
                writer.writeMessage(6, this.search_values_updated, () => this.search_values_updated.serialize(writer));
            if (this.has_attachments_updated)
                writer.writeMessage(7, this.attachments_updated, () => this.attachments_updated.serialize(writer));
            if (this.has_progress)
                writer.writeMessage(8, this.progress, () => this.progress.serialize(writer));
            if (this.has_session_error)
                writer.writeMessage(9, this.session_error, () => this.session_error.serialize(writer));
            if (this.has_operation_error)
                writer.writeMessage(10, this.operation_error, () => this.operation_error.serialize(writer));
            if (this.has_operation_started)
                writer.writeString(11, this.operation_started);
            if (this.has_operation_processing)
                writer.writeString(12, this.operation_processing);
            if (this.has_operation_done)
                writer.writeMessage(13, this.operation_done, () => this.operation_done.serialize(writer));
            if (this.has_session_destroyed)
                writer.writeBool(14, this.session_destroyed);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CallbackEvent {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CallbackEvent();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.stream_updated = reader.readUint64();
                        break;
                    case 2:
                        message.file_read = reader.readBool();
                        break;
                    case 3:
                        reader.readMessage(message.search_updated, () => message.search_updated = CallbackEvent.SearchUpdated.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.indexed_map_updated, () => message.indexed_map_updated = CallbackEvent.IndexedMapUpdated.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.search_map_updated, () => message.search_map_updated = CallbackEvent.SearchMapUpdated.deserialize(reader));
                        break;
                    case 6:
                        reader.readMessage(message.search_values_updated, () => message.search_values_updated = CallbackEvent.SearchValuesUpdated.deserialize(reader));
                        break;
                    case 7:
                        reader.readMessage(message.attachments_updated, () => message.attachments_updated = CallbackEvent.AttachmentsUpdated.deserialize(reader));
                        break;
                    case 8:
                        reader.readMessage(message.progress, () => message.progress = CallbackEvent.Progress.deserialize(reader));
                        break;
                    case 9:
                        reader.readMessage(message.session_error, () => message.session_error = dependency_1.error.NativeError.deserialize(reader));
                        break;
                    case 10:
                        reader.readMessage(message.operation_error, () => message.operation_error = CallbackEvent.OperationError.deserialize(reader));
                        break;
                    case 11:
                        message.operation_started = reader.readString();
                        break;
                    case 12:
                        message.operation_processing = reader.readString();
                        break;
                    case 13:
                        reader.readMessage(message.operation_done, () => message.operation_done = OperationDone.deserialize(reader));
                        break;
                    case 14:
                        message.session_destroyed = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): CallbackEvent {
            return CallbackEvent.deserialize(bytes);
        }
    }
    export namespace CallbackEvent {
        export class SearchUpdated extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                found?: number;
                stat?: Map<string, number>;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("found" in data && data.found != undefined) {
                        this.found = data.found;
                    }
                    if ("stat" in data && data.stat != undefined) {
                        this.stat = data.stat;
                    }
                }
                if (!this.stat)
                    this.stat = new Map();
            }
            get found() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set found(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get stat() {
                return pb_1.Message.getField(this, 2) as any as Map<string, number>;
            }
            set stat(value: Map<string, number>) {
                pb_1.Message.setField(this, 2, value as any);
            }
            static fromObject(data: {
                found?: number;
                stat?: {
                    [key: string]: number;
                };
            }): SearchUpdated {
                const message = new SearchUpdated({});
                if (data.found != null) {
                    message.found = data.found;
                }
                if (typeof data.stat == "object") {
                    message.stat = new Map(Object.entries(data.stat));
                }
                return message;
            }
            toObject() {
                const data: {
                    found?: number;
                    stat?: {
                        [key: string]: number;
                    };
                } = {};
                if (this.found != null) {
                    data.found = this.found;
                }
                if (this.stat != null) {
                    data.stat = (Object.fromEntries)(this.stat);
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.found != 0)
                    writer.writeUint64(1, this.found);
                for (const [key, value] of this.stat) {
                    writer.writeMessage(2, this.stat, () => {
                        writer.writeString(1, key);
                        writer.writeUint64(2, value);
                    });
                }
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SearchUpdated {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SearchUpdated();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.found = reader.readUint64();
                            break;
                        case 2:
                            reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.stat as any, reader, reader.readString, reader.readUint64));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static override deserializeBinary(bytes: Uint8Array): SearchUpdated {
                return SearchUpdated.deserialize(bytes);
            }
        }
        export class IndexedMapUpdated extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                len?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("len" in data && data.len != undefined) {
                        this.len = data.len;
                    }
                }
            }
            get len() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set len(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                len?: number;
            }): IndexedMapUpdated {
                const message = new IndexedMapUpdated({});
                if (data.len != null) {
                    message.len = data.len;
                }
                return message;
            }
            toObject() {
                const data: {
                    len?: number;
                } = {};
                if (this.len != null) {
                    data.len = this.len;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.len != 0)
                    writer.writeUint64(1, this.len);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IndexedMapUpdated {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IndexedMapUpdated();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.len = reader.readUint64();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static override deserializeBinary(bytes: Uint8Array): IndexedMapUpdated {
                return IndexedMapUpdated.deserialize(bytes);
            }
        }
        export class SearchMapUpdated extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                update?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("update" in data && data.update != undefined) {
                        this.update = data.update;
                    }
                }
            }
            get update() {
                return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
            }
            set update(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                update?: string;
            }): SearchMapUpdated {
                const message = new SearchMapUpdated({});
                if (data.update != null) {
                    message.update = data.update;
                }
                return message;
            }
            toObject() {
                const data: {
                    update?: string;
                } = {};
                if (this.update != null) {
                    data.update = this.update;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.update.length)
                    writer.writeString(1, this.update);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SearchMapUpdated {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SearchMapUpdated();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.update = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static override deserializeBinary(bytes: Uint8Array): SearchMapUpdated {
                return SearchMapUpdated.deserialize(bytes);
            }
        }
        export class SearchValuesUpdated extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                values?: Map<number, CallbackEvent.SearchValuesUpdated.ValueRange>;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("values" in data && data.values != undefined) {
                        this.values = data.values;
                    }
                }
                if (!this.values)
                    this.values = new Map();
            }
            get values() {
                return pb_1.Message.getField(this, 1) as any as Map<number, CallbackEvent.SearchValuesUpdated.ValueRange>;
            }
            set values(value: Map<number, CallbackEvent.SearchValuesUpdated.ValueRange>) {
                pb_1.Message.setField(this, 1, value as any);
            }
            static fromObject(data: {
                values?: {
                    [key: number]: ReturnType<typeof CallbackEvent.SearchValuesUpdated.ValueRange.prototype.toObject>;
                };
            }): SearchValuesUpdated {
                const message = new SearchValuesUpdated({});
                if (typeof data.values == "object") {
                    message.values = new Map(Object.entries(data.values).map(([key, value]) => [Number(key), CallbackEvent.SearchValuesUpdated.ValueRange.fromObject(value)]));
                }
                return message;
            }
            toObject() {
                const data: {
                    values?: {
                        [key: number]: ReturnType<typeof CallbackEvent.SearchValuesUpdated.ValueRange.prototype.toObject>;
                    };
                } = {};
                if (this.values != null) {
                    data.values = (Object.fromEntries)((Array.from)(this.values).map(([key, value]) => [key, value.toObject()]));
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                for (const [key, value] of this.values) {
                    writer.writeMessage(1, this.values, () => {
                        writer.writeUint32(1, key);
                        writer.writeMessage(2, value, () => value.serialize(writer));
                    });
                }
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SearchValuesUpdated {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SearchValuesUpdated();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.values as any, reader, reader.readUint32, () => {
                                let value;
                                reader.readMessage(message, () => value = CallbackEvent.SearchValuesUpdated.ValueRange.deserialize(reader));
                                return value;
                            }));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static override deserializeBinary(bytes: Uint8Array): SearchValuesUpdated {
                return SearchValuesUpdated.deserialize(bytes);
            }
        }
        export namespace SearchValuesUpdated {
            export class ValueRange extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    min?: number;
                    max?: number;
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("min" in data && data.min != undefined) {
                            this.min = data.min;
                        }
                        if ("max" in data && data.max != undefined) {
                            this.max = data.max;
                        }
                    }
                }
                get min() {
                    return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
                }
                set min(value: number) {
                    pb_1.Message.setField(this, 1, value);
                }
                get max() {
                    return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
                }
                set max(value: number) {
                    pb_1.Message.setField(this, 2, value);
                }
                static fromObject(data: {
                    min?: number;
                    max?: number;
                }): ValueRange {
                    const message = new ValueRange({});
                    if (data.min != null) {
                        message.min = data.min;
                    }
                    if (data.max != null) {
                        message.max = data.max;
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        min?: number;
                        max?: number;
                    } = {};
                    if (this.min != null) {
                        data.min = this.min;
                    }
                    if (this.max != null) {
                        data.max = this.max;
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.min != 0)
                        writer.writeDouble(1, this.min);
                    if (this.max != 0)
                        writer.writeDouble(2, this.max);
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ValueRange {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ValueRange();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.min = reader.readDouble();
                                break;
                            case 2:
                                message.max = reader.readDouble();
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static override deserializeBinary(bytes: Uint8Array): ValueRange {
                    return ValueRange.deserialize(bytes);
                }
            }
        }
        export class AttachmentsUpdated extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                len?: number;
                attachment?: dependency_2.attachment.AttachmentInfo;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("len" in data && data.len != undefined) {
                        this.len = data.len;
                    }
                    if ("attachment" in data && data.attachment != undefined) {
                        this.attachment = data.attachment;
                    }
                }
            }
            get len() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set len(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get attachment() {
                return pb_1.Message.getWrapperField(this, dependency_2.attachment.AttachmentInfo, 2) as dependency_2.attachment.AttachmentInfo;
            }
            set attachment(value: dependency_2.attachment.AttachmentInfo) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_attachment() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                len?: number;
                attachment?: ReturnType<typeof dependency_2.attachment.AttachmentInfo.prototype.toObject>;
            }): AttachmentsUpdated {
                const message = new AttachmentsUpdated({});
                if (data.len != null) {
                    message.len = data.len;
                }
                if (data.attachment != null) {
                    message.attachment = dependency_2.attachment.AttachmentInfo.fromObject(data.attachment);
                }
                return message;
            }
            toObject() {
                const data: {
                    len?: number;
                    attachment?: ReturnType<typeof dependency_2.attachment.AttachmentInfo.prototype.toObject>;
                } = {};
                if (this.len != null) {
                    data.len = this.len;
                }
                if (this.attachment != null) {
                    data.attachment = this.attachment.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.len != 0)
                    writer.writeUint64(1, this.len);
                if (this.has_attachment)
                    writer.writeMessage(2, this.attachment, () => this.attachment.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AttachmentsUpdated {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AttachmentsUpdated();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.len = reader.readUint64();
                            break;
                        case 2:
                            reader.readMessage(message.attachment, () => message.attachment = dependency_2.attachment.AttachmentInfo.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static override deserializeBinary(bytes: Uint8Array): AttachmentsUpdated {
                return AttachmentsUpdated.deserialize(bytes);
            }
        }
        export class Progress extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                uuid?: string;
                detail?: CallbackEvent.Progress.ProgressDetail;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("uuid" in data && data.uuid != undefined) {
                        this.uuid = data.uuid;
                    }
                    if ("detail" in data && data.detail != undefined) {
                        this.detail = data.detail;
                    }
                }
            }
            get uuid() {
                return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
            }
            set uuid(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get detail() {
                return pb_1.Message.getWrapperField(this, CallbackEvent.Progress.ProgressDetail, 2) as CallbackEvent.Progress.ProgressDetail;
            }
            set detail(value: CallbackEvent.Progress.ProgressDetail) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_detail() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                uuid?: string;
                detail?: ReturnType<typeof CallbackEvent.Progress.ProgressDetail.prototype.toObject>;
            }): Progress {
                const message = new Progress({});
                if (data.uuid != null) {
                    message.uuid = data.uuid;
                }
                if (data.detail != null) {
                    message.detail = CallbackEvent.Progress.ProgressDetail.fromObject(data.detail);
                }
                return message;
            }
            toObject() {
                const data: {
                    uuid?: string;
                    detail?: ReturnType<typeof CallbackEvent.Progress.ProgressDetail.prototype.toObject>;
                } = {};
                if (this.uuid != null) {
                    data.uuid = this.uuid;
                }
                if (this.detail != null) {
                    data.detail = this.detail.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.uuid.length)
                    writer.writeString(1, this.uuid);
                if (this.has_detail)
                    writer.writeMessage(2, this.detail, () => this.detail.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Progress {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Progress();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.uuid = reader.readString();
                            break;
                        case 2:
                            reader.readMessage(message.detail, () => message.detail = CallbackEvent.Progress.ProgressDetail.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static override deserializeBinary(bytes: Uint8Array): Progress {
                return Progress.deserialize(bytes);
            }
        }
        export namespace Progress {
            export class ProgressDetail extends pb_1.Message {
                #one_of_decls: number[][] = [[1, 2, 3]];
                constructor(data?: any[] | ({} & (({
                    ticks?: Ticks;
                    notification?: never;
                    stopped?: never;
                } | {
                    ticks?: never;
                    notification?: Notification;
                    stopped?: never;
                } | {
                    ticks?: never;
                    notification?: never;
                    stopped?: boolean;
                })))) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("ticks" in data && data.ticks != undefined) {
                            this.ticks = data.ticks;
                        }
                        if ("notification" in data && data.notification != undefined) {
                            this.notification = data.notification;
                        }
                        if ("stopped" in data && data.stopped != undefined) {
                            this.stopped = data.stopped;
                        }
                    }
                }
                get ticks() {
                    return pb_1.Message.getWrapperField(this, Ticks, 1) as Ticks;
                }
                set ticks(value: Ticks) {
                    pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
                }
                get has_ticks() {
                    return pb_1.Message.getField(this, 1) != null;
                }
                get notification() {
                    return pb_1.Message.getWrapperField(this, Notification, 2) as Notification;
                }
                set notification(value: Notification) {
                    pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
                }
                get has_notification() {
                    return pb_1.Message.getField(this, 2) != null;
                }
                get stopped() {
                    return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
                }
                set stopped(value: boolean) {
                    pb_1.Message.setOneofField(this, 3, this.#one_of_decls[0], value);
                }
                get has_stopped() {
                    return pb_1.Message.getField(this, 3) != null;
                }
                get detail() {
                    const cases: {
                        [index: number]: "none" | "ticks" | "notification" | "stopped";
                    } = {
                        0: "none",
                        1: "ticks",
                        2: "notification",
                        3: "stopped"
                    };
                    return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3])];
                }
                static fromObject(data: {
                    ticks?: ReturnType<typeof Ticks.prototype.toObject>;
                    notification?: ReturnType<typeof Notification.prototype.toObject>;
                    stopped?: boolean;
                }): ProgressDetail {
                    const message = new ProgressDetail({});
                    if (data.ticks != null) {
                        message.ticks = Ticks.fromObject(data.ticks);
                    }
                    if (data.notification != null) {
                        message.notification = Notification.fromObject(data.notification);
                    }
                    if (data.stopped != null) {
                        message.stopped = data.stopped;
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        ticks?: ReturnType<typeof Ticks.prototype.toObject>;
                        notification?: ReturnType<typeof Notification.prototype.toObject>;
                        stopped?: boolean;
                    } = {};
                    if (this.ticks != null) {
                        data.ticks = this.ticks.toObject();
                    }
                    if (this.notification != null) {
                        data.notification = this.notification.toObject();
                    }
                    if (this.stopped != null) {
                        data.stopped = this.stopped;
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.has_ticks)
                        writer.writeMessage(1, this.ticks, () => this.ticks.serialize(writer));
                    if (this.has_notification)
                        writer.writeMessage(2, this.notification, () => this.notification.serialize(writer));
                    if (this.has_stopped)
                        writer.writeBool(3, this.stopped);
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ProgressDetail {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ProgressDetail();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                reader.readMessage(message.ticks, () => message.ticks = Ticks.deserialize(reader));
                                break;
                            case 2:
                                reader.readMessage(message.notification, () => message.notification = Notification.deserialize(reader));
                                break;
                            case 3:
                                message.stopped = reader.readBool();
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static override deserializeBinary(bytes: Uint8Array): ProgressDetail {
                    return ProgressDetail.deserialize(bytes);
                }
            }
        }
        export class OperationError extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                uuid?: string;
                error?: dependency_1.error.NativeError;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("uuid" in data && data.uuid != undefined) {
                        this.uuid = data.uuid;
                    }
                    if ("error" in data && data.error != undefined) {
                        this.error = data.error;
                    }
                }
            }
            get uuid() {
                return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
            }
            set uuid(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get error() {
                return pb_1.Message.getWrapperField(this, dependency_1.error.NativeError, 2) as dependency_1.error.NativeError;
            }
            set error(value: dependency_1.error.NativeError) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_error() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                uuid?: string;
                error?: ReturnType<typeof dependency_1.error.NativeError.prototype.toObject>;
            }): OperationError {
                const message = new OperationError({});
                if (data.uuid != null) {
                    message.uuid = data.uuid;
                }
                if (data.error != null) {
                    message.error = dependency_1.error.NativeError.fromObject(data.error);
                }
                return message;
            }
            toObject() {
                const data: {
                    uuid?: string;
                    error?: ReturnType<typeof dependency_1.error.NativeError.prototype.toObject>;
                } = {};
                if (this.uuid != null) {
                    data.uuid = this.uuid;
                }
                if (this.error != null) {
                    data.error = this.error.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.uuid.length)
                    writer.writeString(1, this.uuid);
                if (this.has_error)
                    writer.writeMessage(2, this.error, () => this.error.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OperationError {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OperationError();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.uuid = reader.readString();
                            break;
                        case 2:
                            reader.readMessage(message.error, () => message.error = dependency_1.error.NativeError.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static override deserializeBinary(bytes: Uint8Array): OperationError {
                return OperationError.deserialize(bytes);
            }
        }
    }
}
