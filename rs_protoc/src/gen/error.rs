// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GrabError {
    #[prost(oneof="grab_error::Error", tags="1, 2, 3, 4, 5, 6, 7")]
    pub error: ::core::option::Option<grab_error::Error>,
}
/// Nested message and enum types in `GrabError`.
pub mod grab_error {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Config {
        #[prost(string, tag="1")]
        pub message: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Communication {
        #[prost(string, tag="1")]
        pub message: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IoOperation {
        #[prost(string, tag="1")]
        pub message: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InvalidRange {
        #[prost(message, optional, tag="1")]
        pub range: ::core::option::Option<super::super::common::RangeInclusive>,
        #[prost(string, tag="2")]
        pub context: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Interrupted {
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NotInitialize {
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Unsupported {
        #[prost(string, tag="1")]
        pub message: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Error {
        #[prost(message, tag="1")]
        Config(Config),
        #[prost(message, tag="2")]
        Communication(Communication),
        #[prost(message, tag="3")]
        IoOperation(IoOperation),
        #[prost(message, tag="4")]
        InvalidRange(InvalidRange),
        #[prost(message, tag="5")]
        Interrupted(Interrupted),
        #[prost(message, tag="6")]
        NotInitialize(NotInitialize),
        #[prost(message, tag="7")]
        Unsupported(Unsupported),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchError {
    #[prost(oneof="search_error::Error", tags="1, 2, 3, 4, 5, 6, 7")]
    pub error: ::core::option::Option<search_error::Error>,
}
/// Nested message and enum types in `SearchError`.
pub mod search_error {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Config {
        #[prost(string, tag="1")]
        pub message: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Communication {
        #[prost(string, tag="1")]
        pub message: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IoOperation {
        #[prost(string, tag="1")]
        pub message: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Regex {
        #[prost(string, tag="1")]
        pub message: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Input {
        #[prost(string, tag="1")]
        pub message: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Grab {
        #[prost(message, optional, tag="1")]
        pub error: ::core::option::Option<super::GrabError>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Aborted {
        #[prost(string, tag="1")]
        pub message: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Error {
        #[prost(message, tag="1")]
        Config(Config),
        #[prost(message, tag="2")]
        Communication(Communication),
        #[prost(message, tag="3")]
        IoOperation(IoOperation),
        #[prost(message, tag="4")]
        Regex(Regex),
        #[prost(message, tag="5")]
        Input(Input),
        #[prost(message, tag="6")]
        Grab(Grab),
        #[prost(message, tag="7")]
        Aborted(Aborted),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NativeError {
    #[prost(enumeration="Severity", tag="1")]
    pub severity: i32,
    #[prost(enumeration="NativeErrorKind", tag="2")]
    pub kind: i32,
    #[prost(string, tag="3")]
    pub message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputationError {
    #[prost(oneof="computation_error::Error", tags="1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15")]
    pub error: ::core::option::Option<computation_error::Error>,
}
/// Nested message and enum types in `ComputationError`.
pub mod computation_error {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DestinationPath {
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SessionCreatingFail {
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Communication {
        #[prost(string, tag="1")]
        pub message: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct OperationNotSupported {
        #[prost(string, tag="1")]
        pub message: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IoOperation {
        #[prost(string, tag="1")]
        pub message: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InvalidData {
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InvalidArgs {
        #[prost(string, tag="1")]
        pub message: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Process {
        #[prost(string, tag="1")]
        pub message: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Protocol {
        #[prost(string, tag="1")]
        pub message: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MultipleInitCall {
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SessionUnavailable {
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Grabbing {
        #[prost(message, optional, tag="1")]
        pub error: ::core::option::Option<super::GrabError>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Sde {
        #[prost(string, tag="1")]
        pub message: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Error {
        #[prost(message, tag="1")]
        DestinationPath(DestinationPath),
        #[prost(message, tag="2")]
        SessionCreatingFail(SessionCreatingFail),
        #[prost(message, tag="3")]
        Communication(Communication),
        #[prost(message, tag="4")]
        OperationNotSupported(OperationNotSupported),
        #[prost(message, tag="5")]
        IoOperation(IoOperation),
        #[prost(message, tag="6")]
        InvalidData(InvalidData),
        #[prost(message, tag="7")]
        InvalidArgs(InvalidArgs),
        #[prost(message, tag="8")]
        Process(Process),
        #[prost(message, tag="9")]
        Protocol(Protocol),
        #[prost(message, tag="10")]
        SearchError(super::SearchError),
        #[prost(message, tag="11")]
        MultipleInitCall(MultipleInitCall),
        #[prost(message, tag="12")]
        SessionUnavailable(SessionUnavailable),
        #[prost(message, tag="13")]
        NativeError(super::NativeError),
        #[prost(message, tag="14")]
        Grabbing(Grabbing),
        #[prost(message, tag="15")]
        Sde(Sde),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NativeErrorKind {
    FileNotFound = 0,
    UnsupportedFileType = 1,
    ComputationFailed = 2,
    Configuration = 3,
    Interrupted = 4,
    OperationSearch = 5,
    NotYetImplemented = 6,
    ChannelError = 7,
    Io = 8,
    Grabber = 9,
}
impl NativeErrorKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            NativeErrorKind::FileNotFound => "FileNotFound",
            NativeErrorKind::UnsupportedFileType => "UnsupportedFileType",
            NativeErrorKind::ComputationFailed => "ComputationFailed",
            NativeErrorKind::Configuration => "Configuration",
            NativeErrorKind::Interrupted => "Interrupted",
            NativeErrorKind::OperationSearch => "OperationSearch",
            NativeErrorKind::NotYetImplemented => "NotYetImplemented",
            NativeErrorKind::ChannelError => "ChannelError",
            NativeErrorKind::Io => "Io",
            NativeErrorKind::Grabber => "Grabber",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FileNotFound" => Some(Self::FileNotFound),
            "UnsupportedFileType" => Some(Self::UnsupportedFileType),
            "ComputationFailed" => Some(Self::ComputationFailed),
            "Configuration" => Some(Self::Configuration),
            "Interrupted" => Some(Self::Interrupted),
            "OperationSearch" => Some(Self::OperationSearch),
            "NotYetImplemented" => Some(Self::NotYetImplemented),
            "ChannelError" => Some(Self::ChannelError),
            "Io" => Some(Self::Io),
            "Grabber" => Some(Self::Grabber),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Severity {
    Warning = 0,
    Error = 1,
}
impl Severity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Severity::Warning => "WARNING",
            Severity::Error => "ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WARNING" => Some(Self::Warning),
            "ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
